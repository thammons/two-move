var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import Engine from '../engine/engine.js';
export default class Context {
    constructor(name, code, options) {
        this.name = name;
        this.code = code;
        this.beforeAllHooks = [];
        this.afterAllHooks = [];
        this.beforeEachHooks = [];
        this.afterEachHooks = [];
        this.tests = [];
        this.focusedTests = [];
        this.discovered = false;
        this.forced = false;
        this.skipped = false;
        this.contexts = [];
        this.engine = (options === null || options === void 0 ? void 0 : options.engine) || Engine.getInstance();
        this.activeContext = this.engine.activeContext;
        this.focused = (options === null || options === void 0 ? void 0 : options.focused) || false;
        this.forced = (options === null || options === void 0 ? void 0 : options.forced) || false;
        this.skipped = (options === null || options === void 0 ? void 0 : options.skipped) || false;
    }
    discover() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.discovered) {
                return;
            }
            this.activeContext.set(this);
            yield this.code();
            for (const context of this.contexts) {
                yield context.discover();
            }
            this.discovered = true;
        });
    }
    execute(focusedOnly, beforeEachHooks = [], afterEachHooks = []) {
        return __awaiter(this, void 0, void 0, function* () {
            this.activeContext.set(this);
            this.engine.reportContextStarted(this);
            for (const hook of this.beforeAllHooks) {
                yield hook.execute();
            }
            const tests = this.findTestsToExecute(focusedOnly);
            for (const test of tests) {
                for (const hook of beforeEachHooks) {
                    yield hook.execute();
                }
                for (const hook of this.beforeEachHooks) {
                    yield hook.execute();
                }
                yield test.execute();
                for (const hook of this.afterEachHooks) {
                    yield hook.execute();
                }
                for (const hook of afterEachHooks) {
                    yield hook.execute();
                }
            }
            const contexts = this.findContextsToExecute(focusedOnly);
            for (const context of contexts) {
                yield context.execute(focusedOnly, [...beforeEachHooks, ...this.beforeEachHooks], [...afterEachHooks, ...this.afterEachHooks]);
            }
            for (const hook of this.afterAllHooks) {
                yield hook.execute();
            }
            this.engine.reportContextFinished();
        });
    }
    addTest(test, focused = false) {
        if (this.skipped) {
            test.skip();
        }
        this.tests.push(test);
        if (focused) {
            this.focusedTests.push(test);
        }
    }
    addBeforeAllHook(hook) {
        this.beforeAllHooks.push(hook);
    }
    addBeforeEachHook(hook) {
        this.beforeEachHooks.push(hook);
    }
    addAfterEachHook(hook) {
        this.afterEachHooks.push(hook);
    }
    addAfterAllHook(hook) {
        this.afterAllHooks.push(hook);
    }
    addChildContext(context) {
        if (this.skipped) {
            context.skip();
        }
        this.contexts.push(context);
    }
    isSkipped() {
        return this.skipped;
    }
    skip() {
        this.skipped = true;
    }
    get numberOfTests() {
        return this.tests.length;
    }
    findTestsToExecute(focusedOnly) {
        if (focusedOnly) {
            if (this.focusedTests.length) {
                return this.focusedTests;
            }
            return this.focused || this.forced ? this.tests : [];
        }
        return this.tests;
    }
    findContextsToExecute(focusedOnly) {
        if (focusedOnly) {
            const focusedContext = this.contexts.filter((context) => context.focused);
            if (focusedContext.length) {
                return focusedContext;
            }
            if (this.focused || this.forced) {
                return this.contexts.map((context) => {
                    context.forced = true;
                    return context;
                });
            }
        }
        return this.contexts;
    }
}
