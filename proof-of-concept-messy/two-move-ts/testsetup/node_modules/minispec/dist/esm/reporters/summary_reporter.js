import BaseConsoleReporter from './base_console_reporter.js';
export default class SummaryReporter extends BaseConsoleReporter {
    constructor() {
        super(...arguments);
        this.skipped = [];
        this.errors = [];
        this.numberOfExecutedTest = 0;
    }
    stopTest(error) {
        const activeTest = this.activeTest;
        super.stopTest();
        this.numberOfExecutedTest++;
        if (error) {
            const fullContextName = this.activeContexts.map((c) => c.name).join(', ');
            const fullTestName = `${fullContextName}, it ${activeTest === null || activeTest === void 0 ? void 0 : activeTest.name}`;
            if (error.message === 'skipped') {
                this.skipped.push({ testName: fullTestName, testLocation: activeTest === null || activeTest === void 0 ? void 0 : activeTest.location });
            }
            else {
                this.errors.push({ testName: fullTestName, testLocation: activeTest === null || activeTest === void 0 ? void 0 : activeTest.location, error: error, stack: error.stack });
            }
        }
        this.activeTest = null;
    }
    summarizeExecution() {
        super.summarizeExecution();
        this.log('');
        if (this.skipped.length) {
            this.reportSkipped();
        }
        if (this.errors.length) {
            this.reportErrors();
        }
        if (this.timerStopedAt) {
            let intervals = '';
            if (this.timerIntervals.length) {
                let intervalStartingValue = this.timerStartedAt;
                this.timerIntervals.forEach((interval) => {
                    if (intervals.length) {
                        intervals = `${intervals}, `;
                    }
                    const intervalName = interval.keys().next().value;
                    const intervalValue = interval.values().next().value;
                    intervals = `${intervals}${intervalName} took ${intervalValue - intervalStartingValue} milliseconds`;
                    intervalStartingValue = intervalValue;
                });
                intervals = ` (${intervals.trim()})`;
            }
            this.log(`Finished in ${this.timerStopedAt - this.timerStartedAt} milliseconds${intervals}`);
        }
        else {
            this.log('Finished');
        }
        const numberOfExecutedTest = this.numberOfExecutedTest - this.skipped.length;
        if (numberOfExecutedTest) {
            let skippedString = '';
            if (this.skipped.length) {
                skippedString = ` (${this.skipped.length} skipped)`;
            }
            if (this.errors.length) {
                this.log(this.red(`${this.pluralize('test', numberOfExecutedTest)}${skippedString}, ${this.pluralize('failure', this.errors.length)}`));
                this.reportFailuresLocations();
            }
            else {
                this.log(this.green(`${this.pluralize('test', numberOfExecutedTest)}${skippedString}, no failure 👏`));
            }
        }
        else {
            if (this.skipped.length) {
                this.log(this.yellow(`No test has been executed (${this.skipped.length} skipped) 🤔`));
            }
            else {
                this.log(this.yellow('No test has been executed 🤔'));
            }
        }
    }
    reportSkipped() {
        this.error('Skipped:');
        this.skipped.forEach((skipped, index) => {
            const prefix = `  ${index + 1})`;
            this.error('');
            this.error(`${prefix} ${this.yellow(skipped.testName)}`);
            this.error(this.pad(this.yellow(`# ${skipped.testLocation}`), prefix.length + 1));
            this.error('');
        });
    }
    reportErrors() {
        this.error('Failures:');
        this.errors.forEach((error, index) => {
            var _a, _b, _c, _d;
            const prefix = `  ${index + 1})`;
            this.error('');
            this.error(`${prefix} ${error.testName}`);
            if ((_a = error.error) === null || _a === void 0 ? void 0 : _a.message) {
                const message = error.error.message;
                this.error(this.pad(this.red(message), prefix.length + 1));
            }
            if (((_b = error.error) === null || _b === void 0 ? void 0 : _b.actual) && ((_c = error.error) === null || _c === void 0 ? void 0 : _c.expected)) {
                this.error('');
                this.error(this.red(this.pad(`  expected: ${error.error.expected}`, prefix.length + 1)));
                this.error(this.red(this.pad(`       got: ${error.error.actual}`, prefix.length + 1)));
            }
            if ((_d = error.error) === null || _d === void 0 ? void 0 : _d.operator) {
                this.error('');
                this.error(this.red(this.pad(`  (compared using ${error.error.operator})`, prefix.length + 1)));
            }
            if (error.stack) {
                this.error(this.pad(this.green(`# ${this.findSpec(error.stack)}`), prefix.length + 1));
            }
            this.error('');
        });
    }
    reportFailuresLocations() {
        this.error('');
        this.error('Spec with failures:');
        this.error('');
        for (const error of this.errors) {
            const location = error.testLocation || (error.stack && this.findSpec(error.stack)) || undefined;
            if (location === undefined) {
                return;
            }
            this.error(this.red(location));
        }
    }
    pad(message, length) {
        const pad = Array(length + 1).join(' ');
        return message.split('\n').map((m) => `${pad}${m}`).join('\n');
    }
    findSpec(stack) {
        const regexp = /^at[\s]*.*$/;
        try {
            const matches = stack
                .split('\n')
                .filter((m) => regexp.test(m.trim()))[0]
                .trim()
                .match(/^at\s*(.*)$/);
            if (matches && matches.length > 1) {
                return matches[1];
            }
        }
        catch (_a) {
            // We've not been able to properly find spec files in the stack trace
            // We just ignore the error
        }
        return '';
    }
    pluralize(word, number) {
        return `${number} ${word}${number > 1 ? 's' : ''}`;
    }
}
